<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Yang</title>
    <link>http://www.choyang.me/post/index.xml</link>
    <description>Recent content in Posts on Yang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Yang Cao</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>保持github中fork别人repo的更新</title>
      <link>http://www.choyang.me/post/github-fork-repo/</link>
      <pubDate>Sun, 16 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.choyang.me/post/github-fork-repo/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;Clone your fork:
&lt;code&gt;
git clone git@github.com:YOUR-USERNAME/YOUR-FORKED-REPO.git
&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add remote from original repository in your forked repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd into/cloned/fork-repo
git remote add upstream git://github.com/ORIGINAL-DEV-USERNAME/REPO-YOU-FORKED-FROM.git
git fetch upstream
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Updating your fork from original repo to keep up with their changes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git pull upstream master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;updated your local repo and need to push your changes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/CristinaSolana/1885435&#34; target=&#34;_blank&#34;&gt;https://gist.github.com/CristinaSolana/1885435&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hugo建立的网站托管至github pages</title>
      <link>http://www.choyang.me/post/hugo/</link>
      <pubDate>Tue, 21 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.choyang.me/post/hugo/</guid>
      <description>&lt;h2 id=&#34;github-pages&#34;&gt;github pages&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://pages.github.com&#34; target=&#34;_blank&#34;&gt;github pages&lt;/a&gt;,&lt;a href=&#34;https://bitbucket.org/product&#34; target=&#34;_blank&#34;&gt;bitbucket&lt;/a&gt;,&lt;a href=&#34;https://gitlab.com&#34; target=&#34;_blank&#34;&gt;gitlab&lt;/a&gt;是免费的可以用来搭建博客和托管项目网页的工具，这里我们选择最常用的github pages来托管网站。&lt;/p&gt;

&lt;p&gt;github pages分为两类&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;个人或者机构账户主页，必须为&lt;code&gt;username.github.io&lt;/code&gt;,只能在&lt;code&gt;master&lt;/code&gt;分支中建立主页。
&lt;img src=&#34;http://www.choyang.me/post/2017-03-21-hugo-hosting-github/github_personal_page.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;项目主页，可以在&lt;code&gt;master&lt;/code&gt;分支，&lt;code&gt;master/docs&lt;/code&gt;文件夹，&lt;code&gt;gh-pages&lt;/code&gt;分支建立项目主页
&lt;img src=&#34;http://www.choyang.me/post/2017-03-21-hugo-hosting-github/github_project_page.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此有以下几种方法将hugo网站托管至github pages&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网站源文件与网站内容分别存在不同的仓库，内容保存在&lt;code&gt;uername.github.io&lt;/code&gt;，源文件保存在&lt;code&gt;website-source&lt;/code&gt;中，注意这里需要设置&lt;code&gt;publicDir=&amp;quot;../username.github.io&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;网站源文件与网站内容同一个repo下的两个分支，master（网站内容）， source（网站源文件），选择master分支建立github pages&lt;/li&gt;
&lt;li&gt;网站源文件与网站内容同一个repo下的两个分支，master（网站源文件）， gh-pages（网站内容），选择gh-pages分支建立github pages&lt;/li&gt;
&lt;li&gt;一个分支，网站保存在master下的docs文件夹，选择&lt;code&gt;master/docs&lt;/code&gt;建立githubpages，但这总情况只能选择项目主页，所以在构建个人站点的时候不适合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;明显第一种方法最简单，保存在不同分支中的做法涉及两个分支的操作，相信一般人对git分支操作比较头大（当然也包括俺），所以我本人选择了第一种方法来托管个人站点。&lt;i&gt;&lt;strong&gt;详细建个人网站的人对于如何使用git和github应该有所了解&lt;/strong&gt;&lt;/i&gt;&lt;/p&gt;

&lt;h3 id=&#34;绑定域名&#34;&gt;绑定域名&lt;/h3&gt;

&lt;p&gt;有些人想把github pages绑定到个人的域名。这就需要在网站根目录建立&lt;code&gt;CNAME&lt;/code&gt;文件，写入自己的域名。然后按以下步骤配置域名：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置主机记录&lt;code&gt;@&lt;/code&gt;,记录类型为&lt;code&gt;CNAME&lt;/code&gt;, 记录值为&lt;code&gt;yiluheihei.github.io.&lt;/code&gt;注意后边有个点。 ,将&lt;code&gt;choyang.me&lt;/code&gt;域名映射到&lt;code&gt;yiluheihei.github.io&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置主机记录&lt;code&gt;www&lt;/code&gt;，记录类型为&lt;code&gt;A&lt;/code&gt;，记录值是IP &lt;code&gt;192.30.252.154&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置主机记录&lt;code&gt;www&lt;/code&gt;，记录类型为&lt;code&gt;A&lt;/code&gt;，记录值是IP &lt;code&gt;192.30.252.153&lt;/code&gt;，这两个是github pages的IP地址，访问这两个IP表示方位github pages&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;稍等一小会，域名&lt;code&gt;choyang.me&lt;/code&gt;就可以访问，重定向到&lt;code&gt;yiluheihei.github.io&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.choyang.me/post/2017-03-21-hugo-hosting-github/domain_setting.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>利用hugo和blogdown创建网站</title>
      <link>http://www.choyang.me/post/2017-03-20-making-websites-with-blogdown-and-hugo-with-hugo-academic-theme/</link>
      <pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.choyang.me/post/2017-03-20-making-websites-with-blogdown-and-hugo-with-hugo-academic-theme/</guid>
      <description>&lt;p&gt;hugo是一个可以快速建立静态网站的生成器，比如个人主页、博客、公司主页、项目介绍等。相对于其他静态网站生成器，hugo具有安装方便，网页编译生成速度快、实时刷新页面等特点。blogdown则整合了Rmarkdown和hugo的功能来帮助人们在R环境中建立网站（当然也可以是markdown）。&lt;/p&gt;

&lt;h2 id=&#34;安装工具&#34;&gt;安装工具&lt;/h2&gt;

&lt;p&gt;下载安装R和Rstudio（相信常用R的自己电脑上必然已经装好了），然后安装R包blogdown。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;devtools::install_github(&#39;rstudio/blogdown&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后&lt;code&gt;blogdown::install_hugo()&lt;/code&gt;可以用来安装hugo，当然也可以根据自己的操作系统从hugo官网安装，详细步骤参见&lt;a href=&#34;https://gohugo.io/overview/installing/。&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/overview/installing/。&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;选择academic主题建站&#34;&gt;选择academic主题建站&lt;/h2&gt;

&lt;p&gt;hugo提供了很多主题来建立网站， 参照&lt;a href=&#34;http://themes.gohugo.io&#34; target=&#34;_blank&#34;&gt;http://themes.gohugo.io&lt;/a&gt; 选择自己喜欢的主题，我们选择&lt;code&gt;hugo-academic&lt;/code&gt;主题。首先创建一个空文件夹构建网站，所以可以用Rstudio来创建一个Project。然后利用下面代码会在根目录下创建网站的源代码，主要包括：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt; blogdown::new_site(theme=&#39;gcushen/hugo-academic&#39;)` 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;contig.toml&lt;/code&gt;：网站的配置文件，如baseurl，title等，不同主题可设置的参数也不同，具体可查看主题的说明文档；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./archetypes&lt;/code&gt;：包括内容类型，在创建新内容时自动生成内容的配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./themes&lt;/code&gt;: 选定的主题；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./layout&lt;/code&gt;: 网站的模板&lt;code&gt;template&lt;/code&gt;，设定了网站的展现形式；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./content&lt;/code&gt;:根据模板生成的网站的内容，采用markdown格式，关于&lt;a href=&#34;https://gohugo.io/templates/overview/&#34; target=&#34;_blank&#34;&gt;template&lt;/a&gt;以后会详细介绍。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./static&lt;/code&gt;文件夹：css、js、img、media等，决定网站的外观&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后运行&lt;code&gt;blogdown::server_site()&lt;/code&gt;就会生成站点，可以部署至服务器访问，默认根目录建立&lt;code&gt;public&lt;/code&gt;文件夹来存储站点，可以设置&lt;code&gt;confog.toml&lt;/code&gt;文件中的&lt;code&gt;publishDir&lt;/code&gt;参数来修改。&lt;/p&gt;

&lt;h2 id=&#34;个性化设置&#34;&gt;个性化设置&lt;/h2&gt;

&lt;p&gt;随后可根据实际情况修改站点，由hugo构建的网站内容都是由&lt;strong&gt;markdown&lt;/strong&gt;文本参考模板构成，其网站内容在&lt;code&gt;content&lt;/code&gt;文件夹中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;baseurl&lt;/code&gt;:加你站点的网址，如&lt;code&gt;yiluheihei.github.io&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title&lt;/code&gt;: 网站名称；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;theme&lt;/code&gt;: 主题；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;params&lt;/code&gt;: 个人信息和&lt;code&gt;contact&lt;/code&gt;上显示的信息；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[manu.main]]&lt;/code&gt;链接至各个widget，可通过修改&lt;code&gt;weight&lt;/code&gt;
值改变manu的顺序；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;publishDir&lt;/code&gt;：hugo生成网站的目录，默认为&lt;code&gt;./public&lt;/code&gt;文件夹；我个人是把hugo源文件和生成的网站分别保存在两个repo：&lt;code&gt;personal-website-source&lt;/code&gt;和&lt;code&gt;yiluheihei.github.io&lt;/code&gt;，因此&lt;code&gt;publishDir = &amp;quot;../yiluheihei.github.io&amp;quot;&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除不必要文件，主页内容在&lt;code&gt;home&lt;/code&gt;中，由多个widget构成，可以删除不必要的widget，&lt;code&gt;weight&lt;/code&gt;表征了各个widget的显示顺序；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每个post的summary，加&lt;code&gt;&amp;#60;&amp;#33;&amp;#45;&amp;#45;more&amp;#45;&amp;#45;&amp;#62;&lt;/code&gt;或者在yaml加上&lt;code&gt;summary&lt;/code&gt;参数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;post、project等参数中（如&lt;code&gt;summary&lt;/code&gt;，&lt;code&gt;abstract&lt;/code&gt;）有&lt;code&gt;&amp;quot;&lt;/code&gt;和&lt;code&gt;\&lt;/code&gt;(LaTex中的&lt;code&gt;\times&lt;/code&gt;)，需要用&lt;code&gt;\&lt;/code&gt;转义，&lt;code&gt;\&amp;quot;&lt;/code&gt;, &lt;code&gt;\\times&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;i&gt;&lt;strong&gt;当然不同的theme的参数也不同，上述都是针对&lt;code&gt;hugo-academic&lt;/code&gt;主题板设置，要根据具体的主题来设置网站的参数。&lt;/strong&gt;&lt;/i&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>文献下载</title>
      <link>http://www.choyang.me/post/2016-11-15-paper-download/</link>
      <pubDate>Tue, 15 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.choyang.me/post/2016-11-15-paper-download/</guid>
      <description>&lt;p&gt;快速的找到自己研究方向或者感兴趣的文献，常常事半功倍，能很大的提高我们的工作效率，对于毕业论文和科研论文的写作也非常有用。由于XXX原因&lt;code&gt;Google&lt;/code&gt;被和谐，&lt;code&gt;pubmed&lt;/code&gt;能搜索生物医学领域文献，并且不太稳定经常XXX。至于后起之“秀”度娘学术和微软必应学术搜索，不论在搜索数量、质量和功能与&lt;code&gt;Google&lt;/code&gt;学术都没有可比性，也许它们与&lt;code&gt;Google&lt;/code&gt;学术之间的差距要比中美学术之间的差异还要大。下面道一道我经常用的&lt;code&gt;Google&lt;/code&gt;学术搜索镜像和文献全文下载方法&lt;strong&gt;(许多非开源杂志主页不提供全文下载)&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&#34;目前俺常用的goolge学术镜像&#34;&gt;目前俺常用的Goolge学术镜像&lt;/h1&gt;

&lt;p&gt;目前有许多&lt;code&gt;Google&lt;/code&gt;学术镜像可以使用,俺常用的镜像有有下面几个，当然有其他更好的镜像就更好了。俺一般先使用比较稳定方便的&lt;code&gt;Glgoo&lt;/code&gt;学术搜索，如果&lt;code&gt;Glgoo&lt;/code&gt;被和谐，再尝试其他两个&lt;code&gt;Google&lt;/code&gt;学术搜索导航。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Glgoo&lt;/code&gt;学术搜索:速度非常快，用很久了比较稳定

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://xueshu.glgoo.org&#34; target=&#34;_blank&#34;&gt;http://xueshu.glgoo.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scholar.glgoo.org&#34; target=&#34;_blank&#34;&gt;http://scholar.glgoo.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;www.404bus.com&#34; target=&#34;_blank&#34;&gt;虫部落404BUS&lt;/a&gt;： &lt;a href=&#34;http://www.404bus.com&#34; target=&#34;_blank&#34;&gt;http://www.404bus.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dir.scmor.com/google/&#34; target=&#34;_blank&#34;&gt;思谋学术&lt;/a&gt;：&lt;a href=&#34;http://dir.scmor.com/google/&#34; target=&#34;_blank&#34;&gt;http://dir.scmor.com/google/&lt;/a&gt;
&lt;code&gt;Google&lt;/code&gt;学术搜索导航包含很多&lt;code&gt;Google&lt;/code&gt;学术镜像，可以选择使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;google学术搜索&#34;&gt;Google学术搜索&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Google&lt;/code&gt;作为搜索引擎中的老大有很多搜索技巧，掌握一些常见的搜索技巧可以很大的提高工作效率，下边举几个常用例子（更多的说明可以看&lt;code&gt;Google&lt;/code&gt;帮助）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在搜索词上加上双引号就表示精确搜索，显示与搜索关键词完全匹配的结果&lt;/li&gt;
&lt;li&gt;按作者搜索，限定作者进行搜索:&lt;code&gt;[作者：&amp;quot;knuth&amp;quot;]&lt;/code&gt;,搜索作者姓名中含knuth的结果&lt;/li&gt;
&lt;li&gt;减号表示搜索结果不包含减号后边的词，减号前有空格，后面没有：&lt;code&gt;[作者：&amp;quot;knuth&amp;quot;] -DE&lt;/code&gt;表示搜索结果中不能包含词&lt;code&gt;&amp;quot;DE&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些条件限制搜索位置，如&lt;code&gt;intitle&lt;/code&gt;、&lt;code&gt;inurl&lt;/code&gt;等限定搜索标题和url地址；&lt;code&gt;filetype&lt;/code&gt;限制搜索结果的类型；&lt;code&gt;AND&lt;/code&gt; 或者 &lt;code&gt;OR&lt;/code&gt;组合多种搜索条件；等等等&lt;/p&gt;

&lt;h1 id=&#34;文献全文下载&#34;&gt;文献全文下载&lt;/h1&gt;

&lt;h2 id=&#34;sci-hub免费下载全文的方法&#34;&gt;sci-hub免费下载全文的方法&lt;/h2&gt;

&lt;p&gt;很多杂志的文章在主页上不提供全文下载的，俄罗斯某网站&lt;code&gt;sci-hub&lt;/code&gt;提供文献全文下载，个人使用中感觉除了一些新上线的文献外，&lt;code&gt;sci-hub&lt;/code&gt;都可以搞定。常用镜像有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;国内&lt;code&gt;sci-hub&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主网址：&lt;a href=&#34;http://www.sci-hub.cn&#34; target=&#34;_blank&#34;&gt;http://www.sci-hub.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;备用网址：&lt;a href=&#34;http://www.sci-hub.xyz&#34; target=&#34;_blank&#34;&gt;http://www.sci-hub.xyz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;国外&lt;code&gt;sci-hub&lt;/code&gt;镜像&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sci-hub.cc/&#34; target=&#34;_blank&#34;&gt;http://www.sci-hub.cc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sci-hub.bz/&#34; target=&#34;_blank&#34;&gt;http://www.sci-hub.bz/&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;利用&lt;code&gt;PMID&lt;/code&gt;号或者&lt;code&gt;DOI&lt;/code&gt;下载全文&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果在&lt;code&gt;PubMed&lt;/code&gt;查询到的文献，每篇文献都有一个&lt;code&gt;PubMed&lt;/code&gt;号，我们可以复制这个号码在&lt;code&gt;sci-hub&lt;/code&gt;进行查询。注意是&lt;code&gt;PubMed&lt;/code&gt;号，而不是&lt;code&gt;PMCID&lt;/code&gt;号。这样就可以打开&lt;code&gt;PDF&lt;/code&gt;了。此时可能是自动下载&lt;code&gt;PDF&lt;/code&gt;，或者打开新的PDF预览网页进行手动下载（图1）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/paper_11_15/PMID.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果是在其他数据库或者杂志主页查询到的文献，可以利用文章&lt;code&gt;DOI&lt;/code&gt;号在&lt;code&gt;sci-hub&lt;/code&gt;下载到全文。方法同&lt;code&gt;PMID&lt;/code&gt;,比如&lt;code&gt;DOI&lt;/code&gt;号为&lt;code&gt;10.1016/j.jcv.2015.05.022&lt;/code&gt;，输入&lt;code&gt;DOI&lt;/code&gt;号搜索即可打开文章&lt;code&gt;pdf&lt;/code&gt;页面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;利用关键词下载全文：直接输入关键词即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;手动下载&lt;code&gt;PDF&lt;/code&gt;全文&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;sci-hub&lt;/code&gt;网址样式为&lt;code&gt;http://www.xxx.com.sci-hub.cc/x/xx/xx/xx&lt;/code&gt;。如&lt;code&gt;Nature&lt;/code&gt;文章
&lt;code&gt;Astronomy: A Mars-sizedexoplanet&lt;/code&gt;不提供全文下载，文章网址是：
&lt;a href=&#34;http://www.nature.com/nature/journal/v522/n7556/full/522290a.html，&#34; target=&#34;_blank&#34;&gt;http://www.nature.com/nature/journal/v522/n7556/full/522290a.html，&lt;/a&gt;
根据&lt;code&gt;sci-hub&lt;/code&gt;的规则，改成如下样式：&lt;a href=&#34;http://www.nature.com.sci-hub.cc/nature/journal/v522/n7556/full/522290a.html，&#34; target=&#34;_blank&#34;&gt;http://www.nature.com.sci-hub.cc/nature/journal/v522/n7556/full/522290a.html，&lt;/a&gt;
即可下载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;sci-hub&lt;/code&gt;可能在部分地区部分网络可能出现访问受限的问题，&lt;code&gt;sci-hub&lt;/code&gt;的开发人员会及时处理该问题，所以稍等待修复即可。&lt;/p&gt;

&lt;h2 id=&#34;library-genesis&#34;&gt;Library Genesis&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://gen.lib.rus.ec/&#34; target=&#34;_blank&#34;&gt;Library Genesis&lt;/a&gt;:(&lt;a href=&#34;http://gen.lib.rus.ec/)提供下载&#34; target=&#34;_blank&#34;&gt;http://gen.lib.rus.ec/)提供下载&lt;/a&gt;
电子书、科技论文专利等，它集成了&lt;code&gt;sci-hub&lt;/code&gt;的功能。搜索条件与&lt;code&gt;sci-hub&lt;/code&gt;类似，科技论文搜索只要选中&lt;code&gt;scitific articles&lt;/code&gt;选项即可，可以输入&lt;code&gt;PMID&lt;/code&gt;，&lt;code&gt;DOI&lt;/code&gt;或者关键词搜索（图2）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/paper_11_15/genesis.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;点击&lt;code&gt;libgen&lt;/code&gt;进入下载界面，下载即可（图3和4）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/paper_11_15/genesis2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/paper_11_15/genesis3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;推荐步骤&#34;&gt;推荐步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Glgoo&lt;/code&gt;学术镜像查找文献：&lt;code&gt;Glgoo&lt;/code&gt;比&lt;code&gt;sci-hub&lt;/code&gt;稳定，所以推荐先使用&lt;code&gt;Glgoo&lt;/code&gt;学术镜像查找&lt;/li&gt;
&lt;li&gt;杂志主页不提供全文下载的文献，使用&lt;code&gt;sci-hub&lt;/code&gt;镜像下载（先国内再国外）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sci-hub&lt;/code&gt;不稳定登录不上去的时候，考虑使用&lt;code&gt;library genesis&lt;/code&gt;下载。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;穿墙术&#34;&gt;穿墙术&lt;/h1&gt;

&lt;p&gt;利用穿墙术可以跳上墙头直接看到&lt;code&gt;google&lt;/code&gt;，而不用使用&lt;code&gt;google&lt;/code&gt;镜像，两种使用较多的免费翻墙工具（有钱人可以直接买&lt;code&gt;vpn&lt;/code&gt;）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;xx-net： 详细教程见&lt;a href=&#34;https://github.com/XX-net/XX-Net/wiki/中文文档&#34; target=&#34;_blank&#34;&gt;https://github.com/XX-net/XX-Net/wiki/中文文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;蓝灯： 详情见&lt;a href=&#34;https://github.com/getlantern/forum&#34; target=&#34;_blank&#34;&gt;https://github.com/getlantern/forum&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>magrittr管道操作</title>
      <link>http://www.choyang.me/post/2014-11-15-magrittr/</link>
      <pubDate>Sat, 15 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.choyang.me/post/2014-11-15-magrittr/</guid>
      <description>&lt;p&gt;很多情况下，管道操作符可以很大程度的简化代码，并且使其更加直观、易读、易懂，下面就简单说明了useR2014上颇受R用户喜爱的magrittr包。&lt;/p&gt;

&lt;p&gt;the pipe operator is one (if not THE) most important innovation introduced, this year, to the R ecosystem&lt;/p&gt;

&lt;h3 id=&#34;intro&#34;&gt;Intro&lt;/h3&gt;

&lt;p&gt;类似于linux中的
&lt;code&gt;|&lt;/code&gt;，可以把前一个表达式（函数）的输出（而不用定义中间变量来表示）
直接传递给后面的函数或者表达式，省去不必要中间变量或者括号,代码更加清晰易读。
&lt;a href=&#34;http://cran.r-project.org/web/packages/magrittr&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;magrittr&lt;/strong&gt;&lt;/a&gt;包应运而生，它提供
了一系列的管道操作符，如&lt;code&gt;%&amp;gt;%&lt;/code&gt;,&lt;code&gt;x %&amp;gt;% f&lt;/code&gt;等价于&lt;code&gt;f(x)&lt;/code&gt;。
2014年useR会议介绍magrittr之后，有人评价：&lt;a href=&#34;http://www.r-statistics.com/2014/08/simpler-r-coding-with-pipes-the-present-and-future-of-the-magrittr-package/&#34; target=&#34;_blank&#34;&gt;the pipe operator is one (if
not THE) most important innovation introduced, this year, to the R
ecosystem&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;basics&#34;&gt;Basics&lt;/h3&gt;

&lt;h4 id=&#34;produce-values&#34;&gt;Produce values&lt;/h4&gt;

&lt;p&gt;通过使用管道操作符，可以从语义上改变我们写代码的方式，使代码更加简洁易读,管道操作
符的功能为&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认情况下，左边的结果默认作为右边函数的第一个参数，可省略，如下面的&lt;code&gt;transform&lt;/code&gt;
&lt;code&gt;as.Data&lt;/code&gt;和&lt;code&gt;format&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;%&amp;gt;%&lt;/code&gt;可以以嵌套的方式使用，例如它可以作用于表达式来计算函数的参数，如
&lt;code&gt;Date = paste(1973, Month, Day, sep = &amp;quot;-&amp;quot;) %&amp;gt;% as.Date&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果不是传递作为第一个参数用&lt;code&gt;.&lt;/code&gt;表示，如&lt;code&gt;aggregate(. ~ Date %&amp;gt;% format(&amp;quot;%W&amp;quot;), ., mean)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;公式中的&lt;code&gt;.&lt;/code&gt;并不影响管道操作符，如&lt;code&gt;aggregate(. ~ Date %&amp;gt;% format(&amp;quot;%W&amp;quot;), ., mean)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果传递的右边函数只需要一个参数，那么可以省略参数和括号，&lt;code&gt;head&lt;/code&gt;,当然&lt;code&gt;head(.)&lt;/code&gt;和&lt;code&gt;head()&lt;/code&gt;也可以&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;管道操作符左边的函数（包含从上一步传递过来的&lt;code&gt;.&lt;/code&gt;)为一元函数如&lt;code&gt;aggregate(. ~ Date %&amp;gt;% format(&amp;quot;%W&amp;quot;), ., mean)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;library(magrittr)
weekly &amp;lt;-
  airquality %&amp;gt;%
  transform(Date = paste(1973, Month, Day, sep = &amp;ldquo;-&amp;rdquo;) %&amp;gt;% as.Date) %&amp;gt;%
  aggregate(. ~ Date %&amp;gt;% format(&amp;ldquo;%W&amp;rdquo;), ., mean) %&amp;gt;%
  head&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面代码包括三个部分，输入(airquality)，一系列的数据转换(&lt;code&gt;transform&lt;/code&gt;,
&lt;code&gt;aggregate&lt;/code&gt;)和输出(weekly)，类似函数的定义,所以它可以看成是一个函数的
定义和调用的过程，容易读写和理解。&lt;/p&gt;

&lt;p&gt;当然你也可以不用&lt;code&gt;%&amp;gt;%&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;weekly &amp;lt;- aggregate(. ~ format(Date,&amp;quot;%W&amp;quot;),
  transform(airquality, Date = as.Date(paste(1973, Month, Day, sep = &amp;quot;-&amp;quot;))),
  mean)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然这种写法可读性较差，难于理解，含有多对圆括号，更不利于别人的阅读；或者使用
中间变量来避免圆括号的使用，也不如利用管道操作符容易理解。此外，如果想在代码中间
添加新的计算，使用管道操作显然特别方便。&lt;/p&gt;

&lt;h4 id=&#34;produce-fucntions&#34;&gt;Produce fucntions&lt;/h4&gt;

&lt;p&gt;此外，利用&lt;code&gt;%&amp;gt;%&lt;/code&gt;也可以构造简单的函数，与其基本用法其实是一样的（仅仅是基本用法定义函数的时候
即时调用返回结果），在构造函数的时候没有输入变量，用&lt;code&gt;.&lt;/code&gt;替代输入变量即成功构造了一个函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mae &amp;lt;- . %&amp;gt;% abs %&amp;gt;% mean(na.rm = TRUE)
mae(rnorm(10))

## [1] 0.949347

##等价于
mae &amp;lt;- function(x) {
  mean(abs(x), na.rm = TRUE)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;匿名函数和lambda表达式&#34;&gt;匿名函数和lambda表达式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# 标准的函数定义
mtcars %&amp;gt;%
(function(x) {
  if (nrow(x) &amp;gt; 2) 
    rbind(head(x, 1), tail(x, 1))
  else x
})

##             mpg cyl disp  hp drat   wt  qsec vs am gear carb
## Mazda RX4  21.0   6  160 110 3.90 2.62 16.46  0  1    4    4
## Volvo 142E 21.4   4  121 109 4.11 2.78 18.60  1  1    4    2

# lambda表达式，一元函数的参数用`.`表示

mtcars %&amp;gt;%
{ 
  if (nrow(.) &amp;gt; 0)
    rbind(head(., 1), tail(., 1))
  else .
}

##             mpg cyl disp  hp drat   wt  qsec vs am gear carb
## Mazda RX4  21.0   6  160 110 3.90 2.62 16.46  0  1    4    4
## Volvo 142E 21.4   4  121 109 4.11 2.78 18.60  1  1    4    2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;右边的匿名函数用括号包装起来，括号在管道操作符产生作用前优先计算右边括起来的表达式或者函数,
这时候默认情况下第一个参数应该为省略的&lt;code&gt;.&lt;/code&gt;就不起作用了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1:5 %&amp;gt;% 
  {paste(letters[.])}

## [1] &amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot; &amp;quot;e&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外匿名函数最有用的就是可以用于&lt;code&gt;*pply&lt;/code&gt;系列函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list(1,2,3) %&amp;gt;%
  sapply(. %&amp;gt;% length)

## [1] 1 1 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;嵌套的函数调用&#34;&gt;嵌套的函数调用&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt;在管道操作符的右边可以嵌套调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1:5 %&amp;gt;% 
  paste(letters[.])

## [1] &amp;quot;1 a&amp;quot; &amp;quot;2 b&amp;quot; &amp;quot;3 c&amp;quot; &amp;quot;4 d&amp;quot; &amp;quot;5 e&amp;quot;

# 等价于
1:5 %&amp;gt;% 
  paste(.,letters[.])

## [1] &amp;quot;1 a&amp;quot; &amp;quot;2 b&amp;quot; &amp;quot;3 c&amp;quot; &amp;quot;4 d&amp;quot; &amp;quot;5 e&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;advances&#34;&gt;Advances&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;magrittr&lt;/strong&gt;提供了三个其他的，辅助的管道操作符，在某些特定情况下，它们使我们更加
方便的实现各种操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%T&amp;gt;%&lt;/code&gt;和&lt;code&gt;%&amp;gt;%&lt;/code&gt;类似，只是它返回管道操作符左侧的值，通常用于流程中产生其他
副作用的步骤(临时的，不改变左侧的结果继续传递给下一个步骤），如(print,
plot, logging, etc)&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- --&gt;

&lt;pre&gt;&lt;code&gt;rnorm(200) %&amp;gt;%
matrix(ncol = 2) %T&amp;gt;%
plot %&amp;gt;% # plot usually does not return anything. 
colSums


## [1] -9.25270 -7.98688

## 其实是下面代码的简写形式

rnorm(200) %&amp;gt;%
matrix(ncol = 2) %&amp;gt;%
{plot(.);.} %&amp;gt;% # plot usually does not return anything. 
colSums


## [1] 11.197969  7.683612
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;%$%&lt;/code&gt;使左侧数据中变量的名称加载到流程的环境中方便我们直接提取，显然他等价于
函数&lt;code&gt;with&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mtcars %$%
  plot(mpg, wt)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;%&amp;lt;&amp;gt;% 必须是流程中的第一个管道操作符，最后的计算结果赋值给其左边变量，它主要作用是 把形如&lt;/code&gt;foo
&amp;lt;- foo %&amp;gt;% bar %&amp;gt;% baz&lt;code&gt;的计算流程简化为&lt;/code&gt;foo %&amp;lt;&amp;gt;% bar %&amp;gt;% baz`&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外为了使R中的基本操作符与管道操作更友好的结合起来，为这些操作符提供了别名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extract  `[`
extract2    `[[`
use_series  `$`
add `+`
subtract    `-`
multiply_by `*`
raise_to_power  `^`
multiply_by_matrix  `%*%`
divide_by   `/`
divide_by_int   `%/%`
mod `%%`
and `&amp;amp;`
or  `|`
equals  `==`
is_greater_than `&amp;gt;`
is_weakly_greater_than  `&amp;gt;=`
is_less_than    `&amp;lt;`
is_weakly_less_than `&amp;lt;=`
not `!`
set_colnames    `colnames&amp;lt;-`
set_rownames    `rownames&amp;lt;-`
set_names   `names&amp;lt;-`

rnorm(100) %&amp;gt;% `*`(5) %&amp;gt;% `+`(5) %&amp;gt;% 
{
  cat(&amp;quot;Mean:&amp;quot;, mean(.), &amp;quot;Variance:&amp;quot;, var(.),  &amp;quot;\n&amp;quot;)
  head(.)
}

## Mean: 4.785676 Variance: 23.8642

## [1]  7.806526 -4.416972 -1.273823  2.976003  7.568857 12.097451

# 可以写为
rnorm(1000)    %&amp;gt;%
multiply_by(5) %&amp;gt;%
add(5)         %&amp;gt;%
{ 
   cat(&amp;quot;Mean:&amp;quot;, mean(.), 
       &amp;quot;Variance:&amp;quot;, var(.), &amp;quot;\n&amp;quot;)
   head(.)
}

## Mean: 4.982161 Variance: 26.18578

## [1]  0.06189078  8.67467189  6.37717763  6.09563550 -0.65720166  4.04583594
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ref&#34;&gt;Ref&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.revolutionanalytics.com/2014/07/magrittr-simplifying-r-code-with-pipes.html&#34; target=&#34;_blank&#34;&gt;magrittr: Simplifying R code with pipes&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.rstudio.org/2014/12/01/magrittr-1-5/&#34; target=&#34;_blank&#34;&gt;magrittr 1.5&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html&#34; target=&#34;_blank&#34;&gt;magrittr vignette&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>R基础数据结构</title>
      <link>http://www.choyang.me/post/2014-11-12-r-data-structures/</link>
      <pubDate>Wed, 12 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.choyang.me/post/2014-11-12-r-data-structures/</guid>
      <description>&lt;p&gt;R中最基础，也是最重要的数据结构，可以根据其维度和元素的性质来划分：向量（原子向量和列表），矩阵、数组和数据框。&lt;/p&gt;

&lt;p&gt;基本的数据结构根据维度和元素的性质(所有元素的类型是否相同)的可分为&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;同质&lt;/th&gt;
&lt;th&gt;异质&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1d&lt;/td&gt;
&lt;td&gt;Atomic vector&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2d&lt;/td&gt;
&lt;td&gt;Matrix&lt;/td&gt;
&lt;td&gt;Data frame&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;nd&lt;/td&gt;
&lt;td&gt;Array&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其他复杂的类型的数据都是基于以上类型构建的(OOP)，R中标量表示为长度为1的向量&lt;/p&gt;

&lt;p&gt;了解一个对象的数据结构的构成最好的方法是利用函数&lt;code&gt;str&lt;/code&gt;(structue的简写),显示对象的
内部结构&lt;/p&gt;

&lt;h4 id=&#34;vector&#34;&gt;Vector&lt;/h4&gt;

&lt;p&gt;最基本的数据类型,表现为两种形式：原子向量(atomic
vector)和列表(list),区别就在于
元素的类型是否都一样，向量的三个基本特征为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类型: &lt;code&gt;typeof&lt;/code&gt;,其元素的类型&lt;/li&gt;
&lt;li&gt;长度: &lt;code&gt;length&lt;/code&gt;,元素个数&lt;/li&gt;
&lt;li&gt;属性： &lt;code&gt;attributes&lt;/code&gt;,额外的任意的元数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;is.vector&lt;/code&gt;不是用来检测对象是否为向量,仅当向量除names属性外不含其他属性的时候
才会返回&lt;code&gt;TRUE&lt;/code&gt;,&lt;code&gt;is.atomic(x) || is.list(x)&lt;/code&gt;用于判断对象是否为向量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此外,NULL作为保留字，代表了null对象，常用与表达式或者函数（未定义返回值)的返回值，
它同样是一个原子向量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;is.atomic(NULL)

## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;atomic-vector&#34;&gt;atomic vector&lt;/h5&gt;

&lt;p&gt;常见的原子向量有四种:logical,integer,double(常称为numeric),character,此外，使用较少的
有complex和raw两种&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NA是一个长度为1的逻辑向量,不同类型的向量中NA的类型也不同 NA_real_ (a
double vector), NA_integer_ and NA_character_,
在R都属于保留字(reserved words)&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&#34;类型&#34;&gt;类型&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;用来显示对象的类型，&lt;code&gt;is.*&lt;/code&gt;可用来判定对象是否是某一特定类型（&lt;code&gt;is.character&lt;/code&gt;,
&lt;code&gt;is.double&lt;/code&gt;, &lt;code&gt;is.integer&lt;/code&gt;, &lt;code&gt;is.logical&lt;/code&gt;,&lt;code&gt;is.atomic&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;需要注意的是&lt;code&gt;is.numeric&lt;/code&gt;当数据位integer或double时都返回TRUE&lt;/p&gt;

&lt;h5 id=&#34;原子向量元素的强制转化&#34;&gt;原子向量元素的强制转化&lt;/h5&gt;

&lt;p&gt;每一个原子向量中元素的类型必须相同，当把不同类型的数据构成一个向量时，它们会被转化为最
灵活的类型，由低到高的顺序为logical, integer, double, and character&lt;/p&gt;

&lt;h4 id=&#34;list&#34;&gt;List&lt;/h4&gt;

&lt;p&gt;相比于&lt;code&gt;c&lt;/code&gt;构建向量,list用&lt;code&gt;list&lt;/code&gt;创建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- list(1:3, &amp;quot;a&amp;quot;, c(TRUE, FALSE, TRUE), c(2.3, 5.9))
str(x)

## List of 4
##  $ : int [1:3] 1 2 3
##  $ : chr &amp;quot;a&amp;quot;
##  $ : logi [1:3] TRUE FALSE TRUE
##  $ : num [1:2] 2.3 5.9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list某些情况也可以称作&lt;strong&gt;recursive&lt;/strong&gt;（递归）向量，因为list的元素也可以是list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- list(list(list(list())))
str(x)

## List of 1
##  $ :List of 1
##   ..$ :List of 1
##   .. ..$ : list()

is.recursive(x)

## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;c`可以把多个list合并为一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- list(list(1, 2), c(3, 4))
y &amp;lt;- c(list(1, 2), c(3, 4))
x

## [[1]]
## [[1]][[1]]
## [1] 1
## 
## [[1]][[2]]
## [1] 2
## 
## 
## [[2]]
## [1] 3 4

y

## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
## 
## [[4]]
## [1] 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;返回R内部对象的类型或者存储模式，对于列表它返回list，常用函数&lt;code&gt;is.list&lt;/code&gt;,
&lt;code&gt;as.list&lt;/code&gt;,&lt;code&gt;unlist&lt;/code&gt;(转化为向量，数据会强制转化)，列表用于存储复杂的数据，比如df和
线性模型都是基于列表创建&lt;/p&gt;

&lt;h4 id=&#34;attributes&#34;&gt;attributes&lt;/h4&gt;

&lt;p&gt;任意对象都可包含额外属性来存储对象的元数据，属性可以看成命名的列表，当然不同属性
要求名字不同,&lt;code&gt;attr&lt;/code&gt;提取特定名字的属性，&lt;code&gt;attributes&lt;/code&gt;列出对象的所有属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y &amp;lt;- 1:10
attr(y, &amp;quot;my_attribute&amp;quot;) &amp;lt;- &amp;quot;This is a vector&amp;quot;
attr(y, &amp;quot;my_attribute&amp;quot;)

## [1] &amp;quot;This is a vector&amp;quot;

str(attributes(y))

## List of 1
##  $ my_attribute: chr &amp;quot;This is a vector&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;structure&lt;/code&gt;也可以修改对象的属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;structure(1:10, my_attribute = &amp;quot;This is a vector&amp;quot;)

##  [1]  1  2  3  4  5  6  7  8  9 10
## attr(,&amp;quot;my_attribute&amp;quot;)
## [1] &amp;quot;This is a vector&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当操作运算向量时，默认丢掉大部分附加属性。names，dim（一维的向量转为多维数组
或矩阵等和class(s3类)除外,当然这三 种属性一般不用&lt;code&gt;attr&lt;/code&gt;改变。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;attributes(y[1])

## NULL

attributes(sum(y))

## NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;names&#34;&gt;names&lt;/h5&gt;

&lt;p&gt;三种方法设定向量的names&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x &amp;lt;- c(a = 1, b = 2, c = 3)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x &amp;lt;- 1:3; names(x) &amp;lt;- c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x &amp;lt;- setNames(1:3, c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;names不要求所有元素都是不同的，为了方便根据name提取向量子元素，name保持各不相同&lt;/p&gt;

&lt;h4 id=&#34;factor&#34;&gt;factor&lt;/h4&gt;

&lt;p&gt;属性的一个最大用处是定义因子，levels就是作为因子默认存在的一个附加属性。因子可以看成是仅仅
包含预定义值（levels）的向量，用来存储分类数据。它是基于整型向量构建，附加了两个属性
class（factor）和levels，因子不可以合并(没有意义)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c(factor(&amp;quot;a&amp;quot;), factor(&amp;quot;b&amp;quot;))

## [1] 1 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当变量的可能取值已知时，即使并不知道一个数据集的所有取值。使用因子对于表示存在某些元素
并不含有观测值时更直观&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sex_char &amp;lt;- c(&amp;quot;m&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;m&amp;quot;)
sex_factor &amp;lt;- factor(sex_char, levels = c(&amp;quot;m&amp;quot;, &amp;quot;f&amp;quot;))

table(sex_char)

## sex_char
## m 
## 3

table(sex_factor)

## sex_factor
## m f 
## 3 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，当我们从文件读取数据定义一个数值型df时，如果数据中含有特殊字符（非数字)
如&amp;rdquo;.&amp;ldquo;，“-”等，那么默认情况下这一列会转化为factor而不是数值型向量，可以通过先把它转化为
character类型向量然后再转化为数值型。更好的做法是在读入数据的时候设置&lt;code&gt;na.strings&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此外，可以设置&lt;code&gt;stringsAsFactors = FALSE&lt;/code&gt;,然后需要传话为factor时再转化，不要使用全局的选项
&lt;code&gt;options(stringsAsFactors = FALSE)&lt;/code&gt;,改变全局设置，当与其他的包或者函数结合使用时，可能引起
不必要的麻烦。&lt;/p&gt;

&lt;p&gt;虽然因子经常看起来像字符向量，实际上他们是以整型存储的，所以在对因子做字符处理的时候，可以先把
它转化为character，虽然某些函数可以自动转化因子为characte（&lt;code&gt;gsub()&lt;/code&gt;
,&lt;code&gt;grepl&lt;/code&gt;)，但是像 &lt;code&gt;nchar&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;等函数则会出现错误。&lt;/p&gt;

&lt;h4 id=&#34;矩阵-数组&#34;&gt;矩阵-数组&lt;/h4&gt;

&lt;p&gt;通过设置原子向量的dim属性，可以构建多维数组、矩阵(2维数组)。&lt;code&gt;matrix&lt;/code&gt;和&lt;code&gt;array&lt;/code&gt;也用于构建矩阵和数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Two scalar arguments to specify rows and columns
a &amp;lt;- matrix(1:6, ncol = 3, nrow = 2)
# One vector argument to describe all dimensions
b &amp;lt;- array(1:12, c(2, 3, 2))

# You can also modify an object in place by setting dim()
c &amp;lt;- 1:6
dim(c) &amp;lt;- c(3, 2,1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nrow&lt;/code&gt;,&lt;code&gt;ncol&lt;/code&gt;，&lt;code&gt;dim&lt;/code&gt;:行列数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colnames&lt;/code&gt;,&lt;code&gt;rolnames&lt;/code&gt;:元素名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dimnames&lt;/code&gt;:列表，对数组元素命名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cbind&lt;/code&gt;,&lt;code&gt;rbind&lt;/code&gt;,&lt;code&gt;abind&lt;/code&gt;:合并&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;,&lt;code&gt;aperm&lt;/code&gt;：转置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is.*&lt;/code&gt;,&lt;code&gt;as.*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一维数组，矩阵和向量的区别,print可能相同，但是内部结构不同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;str(1:3)                   # 1d vector

##  int [1:3] 1 2 3

str(matrix(1:3, ncol = 1)) # column vector

##  int [1:3, 1] 1 2 3

str(matrix(1:3, nrow = 1)) # row vector

##  int [1, 1:3] 1 2 3

str(array(1:3, 3))         # &amp;quot;array&amp;quot; vector

##  int [1:3(1d)] 1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，通过设置列表的dim属性，也可以把构建列表矩阵或者数组&lt;/p&gt;

&lt;h4 id=&#34;df&#34;&gt;df&lt;/h4&gt;

&lt;p&gt;df是R中最常用的存储数据的类型，使数据分析更容易。实际上，df一个列表（由多个相同
长度向量构成），同时具有列表和矩阵的属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:3, y = c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;))
str(df)

## &#39;data.frame&#39;:    3 obs. of  2 variables:
##  $ x: int  1 2 3
##  $ y: Factor w/ 3 levels &amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;: 1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建df时,默认情况下strings会转化为factors,通过参数&lt;code&gt;stringsAsFactors&lt;/code&gt;控制。&lt;/p&gt;

&lt;p&gt;df是一个s3类，它的类型(type)反应了构建df向量的类型：列表。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;as.data.frame&lt;/code&gt;转化为df * 向量：一列df *
列表：每一个元素为一列，需要每一元素长度相等 * 矩阵&lt;/p&gt;

&lt;h5 id=&#34;合并&#34;&gt;合并&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rbind&lt;/code&gt;:要求列的names和length必须相同，&lt;code&gt;plyr::rbind.fill&lt;/code&gt;可以用来合并含不同列的df&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cbind&lt;/code&gt;：要求行的length必须相同,忽略rownames。作用于向量时会返回矩阵，除非某个参数是df&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外df是可以看成是一个向量列表，所以df的列也可以是一个列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:3)
df$y &amp;lt;- list(1:2, 1:3, 1:4)
df

##   x          y
## 1 1       1, 2
## 2 2    1, 2, 3
## 3 3 1, 2, 3, 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，当利用&lt;code&gt;data.frame&lt;/code&gt;构建df时，如果参数为list，它会把list的每一个元素作为df的一列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## error 要求list(y)中每个元素的长度与x相同
data.frame(x = 1:3, y = list(1:2, 1:3, 1:4))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是通过&lt;code&gt;I&lt;/code&gt;可以保持原有参数的属性，时list保持一个整体作为df的一列，同样适用于矩阵和数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dfl &amp;lt;- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>R code style</title>
      <link>http://www.choyang.me/post/2014-11-4-r-code-style/</link>
      <pubDate>Tue, 04 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.choyang.me/post/2014-11-4-r-code-style/</guid>
      <description>&lt;p&gt;R作为用于统计计算和图形可视化的高级语言，随着近来来大数据的发展，R语言逐渐成长为数据分析的利器，良好的代码风格使代码更容易阅读，
分享和扩展，下面基于Rstudio首席科学家&lt;a href=&#34;http://had.co.nz/&#34;&gt;hadley&lt;/a&gt;和google的R团队的代码风格做了一些小的调整。&lt;/p&gt;

&lt;h3 id=&#34;符号和命名&#34;&gt;符号和命名&lt;/h3&gt;

&lt;h4 id=&#34;文件名字&#34;&gt;文件名字&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;.R&lt;/em&gt; 作为文件扩展名&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件的命名要与它的功能相关&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GOOD: predict_ad_revenue.R&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BAD: foo.R&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;h4 id=&#34;对象名称&#34;&gt;对象名称&lt;/h4&gt;

&lt;p&gt;标识符中不要含有&lt;em&gt;-&lt;/em&gt; 和&lt;em&gt;_&lt;/em&gt;, 变量名字使用小写, 词之间用&lt;em&gt;.&lt;/em&gt; 分割(variable.name), varibaleName也可以, 个人偏向使用前一种; 函数名每个词第一个字母要大写 (FunctionName), 第一个词是动词, hadely目前是利用&lt;em&gt;_&lt;/em&gt; ；因为R的方法调用都或者某些类的定义使用&lt;em&gt;.&lt;/em&gt;,所以函数的定义不要使用&lt;em&gt;.&lt;/em&gt;; 常量命名规则除了名字开头加个*k*其他与函数一致, (kConstantName)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;variable.name is preferred, variableName is accepted&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GOOD: avg.clicks&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;OK: avgClicks&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BAD: avg_Clicks&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FunctionName&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GOOD: CalculateAvgClicks&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BAD: calculate_avg_clicks , calculateAvgClicks&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Make function names verbs.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例外: When creating a classed object, the function name (constructor) and class should match (e.g.,lm).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常量：k加上常量名称，kConstantName&lt;/p&gt;

&lt;p&gt;当然不能使用R中自定义的已存在的函数和变量的名字&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Bad
T &amp;lt;- FALSE
c &amp;lt;- 10
mean &amp;lt;- function(x) sum(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;句法&#34;&gt;句法&lt;/h3&gt;

&lt;h4 id=&#34;每行代码的字符数&#34;&gt;每行代码的字符数&lt;/h4&gt;

&lt;p&gt;不超过80个字符；如果发现自己的代码行超过80个字符，那么要考虑封装代码至一个简短函数，或者使用&lt;a href=&#34;http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html&#34; target=&#34;_blank&#34;&gt;magrittr&lt;/a&gt;包的管道操作符.&lt;/p&gt;

&lt;h4 id=&#34;缩进&#34;&gt;缩进&lt;/h4&gt;

&lt;p&gt;两个空格, 不要用tab tab与空格一起使用&lt;/p&gt;

&lt;p&gt;例外: 换行在一个括号内, 那么下一行开头和括号内第一个字符对齐&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;long_function_name &amp;lt;- function(a = &amp;quot;a long argument&amp;quot;, 
                               b = &amp;quot;another argument&amp;quot;,
                               c = &amp;quot;another long argument&amp;quot;) {
  # As usual code is indented by two spaces.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;空格&#34;&gt;空格&lt;/h4&gt;

&lt;p&gt;所有的二元操作符两边有一个空格(=, +, -, &amp;lt;-, etc.).&lt;/p&gt;

&lt;p&gt;函数调用传递参数时候=号两边的空格可有可无, 个人觉得应该有空格&lt;/p&gt;

&lt;p&gt;逗号之前不要有空格, 后面要加空格&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;::&lt;/code&gt; 和&lt;code&gt;:::&lt;/code&gt; 两边不需要空格&lt;/p&gt;

&lt;p&gt;GOOD:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tab.prior &amp;lt;- table(df[df$days.from.opt &amp;lt; 0, &amp;quot;campaign.id&amp;quot;])
total &amp;lt;- sum(x[, 1])
total &amp;lt;- sum(x[1, ])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BAD:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tab.prior &amp;lt;- table(df[df$days.from.opt &amp;lt; 0, &amp;quot;campaign.id&amp;quot;])  # Needs spaces around &#39;&amp;lt;&#39;
tab.prior &amp;lt;- table(df[df$days.from.opt &amp;lt; 0, &amp;quot;campaign.id&amp;quot;])  # Needs a space after the comma
tab.prior &amp;lt;- table(df[df$days.from.opt &amp;lt; 0, &amp;quot;campaign.id&amp;quot;])  # Needs a space before &amp;lt;-
tab.prior &amp;lt;- table(df[df$days.from.opt &amp;lt; 0, &amp;quot;campaign.id&amp;quot;])  # Needs spaces around &amp;lt;-
total &amp;lt;- sum(x[, 1])  # Needs a space after the comma
total &amp;lt;- sum(x[, 1])  # Needs a space after the comma, not before
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;括号之前加空格, 调用函数除外&lt;/p&gt;

&lt;p&gt;GOOD:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (debug)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BAD:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if(debug)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;额外的空格 比如为了使代码的等号或者(&amp;lt;-)对齐&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;list(
  total = a + b + c, 
  mean  = (a + b + c) / n
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;括号和方括号的周围不要有空格
GOOD:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (debug) x[1, ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BAD:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if ( debug )  # No spaces around debug
x[1,]  # Needs a space after the comma 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;大括号&#34;&gt;大括号&lt;/h4&gt;

&lt;p&gt;左大括号不要另起一行, 右大括号一定要另起一行, 代码块包含单独语句时括号可省略, 但是代码中大括号是否省略要保持一致&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (is.null(ylim)) {
    ylim &amp;lt;- c(0, 0.06)
}
## xor (but not both)

if (is.null(ylim)) ylim &amp;lt;- c(0, 0.06)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码块要另起一行&lt;/p&gt;

&lt;p&gt;BAD:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (is.null(ylim)) ylim &amp;lt;- c(0, 0.06)
if (is.null(ylim)) {
    ylim &amp;lt;- c(0, 0.06)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;含else代码块要使用大括号&#34;&gt;含else代码块要使用大括号&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;esle&lt;/em&gt; 语句与大括号要在同一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (condition) {
  one or more lines
} else {
  one or more lines
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BAD:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (condition) {
  one or more lines
}
else {
  one or more lines
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BAD:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (condition)
  one line
else
  one line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果条件语句后面跟着简短的语句则可以写在同行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (y &amp;lt; 0 &amp;amp;&amp;amp; debug) message(&amp;quot;Y is negative&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分号&#34;&gt;分号&lt;/h4&gt;

&lt;p&gt;行尾不要使用分号, 不要使用分号将多个语句放在同一行&lt;/p&gt;

&lt;h3 id=&#34;组织&#34;&gt;组织&lt;/h3&gt;

&lt;h4 id=&#34;总体布局和顺序&#34;&gt;总体布局和顺序&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;版权声明&lt;/li&gt;
&lt;li&gt;作者&lt;/li&gt;
&lt;li&gt;文件说明注释, 包括文件是用来做什么以及输入输出的说明&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source()&lt;/code&gt; 和&lt;code&gt;library()&lt;/code&gt;语句&lt;/li&gt;
&lt;li&gt;函数定义&lt;/li&gt;
&lt;li&gt;执行语句, 也就是example (e.g., print, plot)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;附加单元测试文件&lt;em&gt;originalfilename_test.R&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;注释&#34;&gt;注释&lt;/h4&gt;

&lt;p&gt;注释行以一个#开头, 加一个空格, 注释要说明为什么写这行代码（不是代码做了什么）&lt;/p&gt;

&lt;p&gt;有时候会使用注释把代码分割成若干易读和理解的代码块，使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# =================================================================
# why this code
# =================================================================
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Create histogram of frequency of campaigns by pct budget spent.
hist(df$pct.spent,
     breaks = &amp;quot;scott&amp;quot;,  # method for choosing number of buckets
     main   = &amp;quot;Histogram: fraction budget spent by campaignid&amp;quot;,
     xlab   = &amp;quot;Fraction of budget spent&amp;quot;,
     ylab   = &amp;quot;Frequency (count of campaignids)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;

&lt;p&gt;函数的名称一般为动词；函数中的代码块应该可以在一个屏幕上阅读（二三十行）&lt;/p&gt;

&lt;p&gt;####调用&lt;/p&gt;

&lt;p&gt;没有缺省值的参数应该放在前面, 后面跟着有缺省值的参数&lt;/p&gt;

&lt;p&gt;函数定义及调用允许一行多个参数, 换行符要在参数之间&lt;/p&gt;

&lt;p&gt;GOOD&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;PredictCTR &amp;lt;- function(query, property, num.days,
  show.plot = TRUE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BAD&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;PredictCTR &amp;lt;- function(query, property, num.days, show.plot =
  TRUE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单元测试作为函数的example&lt;/p&gt;

&lt;h4 id=&#34;文档&#34;&gt;文档&lt;/h4&gt;

&lt;p&gt;函数应该包含注释块紧接着函数定义的行(函数体), 包含了函数的说明, 参数的使用, 返回值, 建议使用(roxygen2)[&lt;a href=&#34;http://cran.r-project.org/web/packages/roxygen2/index.html]的模式&#34; target=&#34;_blank&#34;&gt;http://cran.r-project.org/web/packages/roxygen2/index.html]的模式&lt;/a&gt;, 便于开发package,&lt;strong&gt;rstudio&lt;/strong&gt;已经很好的整合了&lt;strong&gt;roxygen2&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&#34;自定义函数&#34;&gt;自定义函数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;CalculateSampleCovariance &amp;lt;- function(x, y, verbose = TRUE) {
  #&#39; @description des description Computes the sample covariance between two vectors.
  #&#39; @author  
  #&#39; @param x: One of twovectors whose sample covariance is to be calculated.  
  #&#39; @param y: The other vector.
  #&#39; @param verbose ....
  #&#39; @details x and y must have the same length, greater than one, with no missing
  #&#39;  values.  verbose: If TRUE, prints sample covariance; if not, not. Default
  #&#39;  is TRUE.  Returns: The sample covariance between x and y.
  #&#39; @return ..
  #&#39; @examples
  #&#39; @importFrom
  
  n &amp;lt;- length(x)
  # Error handling
  if (n &amp;lt;= 1 || n != length(y)) {
    stop(&amp;quot;Arguments x and y have different lengths: &amp;quot;, length(x), &amp;quot; and &amp;quot;, 
      length(y), &amp;quot;.&amp;quot;)
  }
  if (TRUE %in% is.na(x) || TRUE %in% is.na(y)) {
    stop(&amp;quot; Arguments x and y must not have missing values.&amp;quot;)
  }
  covariance &amp;lt;- var(x, y)
  if (verbose) 
    cat(&amp;quot;Covariance = &amp;quot;, round(covariance, 4), &amp;quot;.\n&amp;quot;, sep = &amp;quot;&amp;quot;)
  return(covariance)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;此外&lt;/strong&gt;：绝对不要使用,attch的使用会使对象中的变量加载到相应的父环境中，可能会出现同名变量对象&lt;/p&gt;

&lt;h3 id=&#34;ref&#34;&gt;Ref&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stat405.had.co.nz/r-style.html&#34; target=&#34;_blank&#34;&gt;Hadley Wickham&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cran.r-project.org/doc/manuals/R-ints.html#R-coding-standards&#34; target=&#34;_blank&#34;&gt;CRAN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cran.r-project.org/web/packages/formatR/index.html&#34; target=&#34;_blank&#34;&gt;formatR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://csgillespie.wordpress.com/2010/11/23/r-style-guide/&#34; target=&#34;_blank&#34;&gt;Colin Gillespie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.fhcrc.org/bioc/Coding_Standards&#34; target=&#34;_blank&#34;&gt;Bioconductor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
